# Load and parse YAML configuration
locals {
  # Configuration directory paths
  config_base_path       = var.config_path
  repository_config_path = "${local.config_base_path}/repository"
  group_config_path      = "${local.config_base_path}/group"
  ruleset_config_path    = "${local.config_base_path}/ruleset"

  # Read common config (single file - not splittable)
  common_config = yamldecode(file("${local.config_base_path}/config.yml"))

  # Helper: Load and merge all YAML files from a directory
  # Files are sorted alphabetically - later files override earlier ones for duplicate keys
  repository_files = fileset(local.repository_config_path, "*.yml")
  group_files      = fileset(local.group_config_path, "*.yml")
  ruleset_files    = fileset(local.ruleset_config_path, "*.yml")

  # Load individual YAML files (for duplicate detection)
  repository_configs_by_file = {
    for f in sort(tolist(local.repository_files)) :
    f => yamldecode(file("${local.repository_config_path}/${f}"))
  }
  group_configs_by_file = {
    for f in sort(tolist(local.group_files)) :
    f => yamldecode(file("${local.group_config_path}/${f}"))
  }
  ruleset_configs_by_file = {
    for f in sort(tolist(local.ruleset_files)) :
    f => yamldecode(file("${local.ruleset_config_path}/${f}"))
  }

  # Detect duplicate keys across files
  # Build a map of key -> list of files for each config type
  repo_key_occurrences = {
    for key in distinct(flatten([
      for file, config in local.repository_configs_by_file :
      config != null ? keys(config) : []
    ])) :
    key => [
      for file, config in local.repository_configs_by_file :
      file if config != null && contains(keys(config), key)
    ]
  }

  group_key_occurrences = {
    for key in distinct(flatten([
      for file, config in local.group_configs_by_file :
      config != null ? keys(config) : []
    ])) :
    key => [
      for file, config in local.group_configs_by_file :
      file if config != null && contains(keys(config), key)
    ]
  }

  ruleset_key_occurrences = {
    for key in distinct(flatten([
      for file, config in local.ruleset_configs_by_file :
      config != null ? keys(config) : []
    ])) :
    key => [
      for file, config in local.ruleset_configs_by_file :
      file if config != null && contains(keys(config), key)
    ]
  }

  # Filter to only duplicates (appearing in more than one file)
  duplicate_repository_keys = {
    for key, files in local.repo_key_occurrences :
    key => files if length(files) > 1
  }

  duplicate_group_keys = {
    for key, files in local.group_key_occurrences :
    key => files if length(files) > 1
  }

  duplicate_ruleset_keys = {
    for key, files in local.ruleset_key_occurrences :
    key => files if length(files) > 1
  }

  # Load and merge repository configs from config/repository/ directory
  repos_config = merge([
    for f in sort(tolist(local.repository_files)) :
    yamldecode(file("${local.repository_config_path}/${f}"))
  ]...)

  # Load and merge group configs from config/group/ directory
  groups_config = merge([
    for f in sort(tolist(local.group_files)) :
    yamldecode(file("${local.group_config_path}/${f}"))
  ]...)

  # Load and merge ruleset configs from config/ruleset/ directory
  # Note: templates.yml is loaded separately and not merged with rulesets_config
  rulesets_config = merge([
    for f in sort(tolist(local.ruleset_files)) :
    yamldecode(file("${local.ruleset_config_path}/${f}"))
    if f != "templates.yml" # Exclude templates from regular rulesets
  ]...)

  # Load ruleset templates from config/ruleset/default-rulesets.yml
  # Templates are referenced by name in repository/group configurations
  # This file now contains both templates and default rulesets
  ruleset_templates = try(
    yamldecode(file("${local.ruleset_config_path}/default-rulesets.yml")),
    {}
  )

  # Load webhook definitions from config/webhook/ directory
  # Directory is optional - missing directory results in empty map
  webhook_dir = "${local.config_base_path}/webhook"
  webhook_files = try(
    fileset(local.webhook_dir, "*.yml"),
    toset([])
  )
  webhooks_config = merge([
    for f in sort(tolist(local.webhook_files)) :
    try(yamldecode(file("${local.webhook_dir}/${f}")), {})
  ]...)

  # Extract values from YAML
  github_org      = local.common_config.organization
  is_organization = lookup(local.common_config, "is_organization", true)
  subscription    = lookup(local.common_config, "subscription", "free")
  config_groups   = local.groups_config
  repos_yaml      = local.repos_config

  # Organization-level actions configuration
  # Defaults to null if not specified (no org-level actions resource created)
  # Only applicable for organizations, not personal accounts
  org_actions_config = local.is_organization ? lookup(local.common_config, "actions", null) : null

  # Subscription tier feature availability
  # - free: Rulesets only work on public repositories
  # - pro: Rulesets work on public and private repositories
  # - team/enterprise: Full ruleset support including push rulesets
  rulesets_require_paid_for_private = contains(["free"], local.subscription)

  # Merge multiple config groups for each repository
  # Groups are applied sequentially: later groups override single values, lists are merged
  merged_configs = {
    for repo_name, repo_config in local.repos_yaml : repo_name => merge(
      # Apply each group sequentially - merge will override with later values
      [
        for group_name in repo_config.groups :
        lookup(local.config_groups, group_name, {})
      ]...
    )
  }

  # Merge topics from all groups for each repository
  merged_topics = {
    for repo_name, repo_config in local.repos_yaml : repo_name => distinct(flatten([
      # Topics from all groups
      for group_name in repo_config.groups :
      lookup(lookup(local.config_groups, group_name, {}), "topics", [])
    ]))
  }

  # Merge teams from all groups for each repository
  merged_teams = {
    for repo_name, repo_config in local.repos_yaml : repo_name => merge(
      # Apply each group's teams sequentially - later groups override
      [
        for group_name in repo_config.groups :
        lookup(lookup(local.config_groups, group_name, {}), "teams", {})
      ]...
    )
  }

  # Merge collaborators from all groups for each repository
  merged_collaborators = {
    for repo_name, repo_config in local.repos_yaml : repo_name => merge(
      # Apply each group's collaborators sequentially - later groups override
      [
        for group_name in repo_config.groups :
        lookup(lookup(local.config_groups, group_name, {}), "collaborators", {})
      ]...
    )
  }

  # Merge rulesets from all groups for each repository
  # Rulesets are collected from groups, then repo-specific rulesets are added
  # Supports both direct ruleset names and template references with overrides
  # Note: On free tier, rulesets are skipped for private repositories
  merged_rulesets = {
    for repo_name, repo_config in local.repos_yaml : repo_name => merge([
      for idx, ruleset_entry in flatten(concat(
        # Collect ruleset entries from all groups
        [
          for group_name in repo_config.groups :
          lookup(lookup(local.config_groups, group_name, {}), "rulesets", [])
        ],
        # Add repo-specific rulesets
        [lookup(repo_config, "rulesets", [])]
        )) : {
        # Generate a unique key for this ruleset
        # For templates, use "tpl-<template_name>-<idx>" to avoid collisions
        # For direct references, use the ruleset name as-is
        (try(ruleset_entry.template, null) != null ?
          "tpl-${ruleset_entry.template}-${idx}" :
          tostring(ruleset_entry)
          ) = (
          # If entry is a map with 'template' key, resolve from templates
          try(ruleset_entry.template, null) != null ? (
            # Validate template exists
            lookup(local.ruleset_templates, ruleset_entry.template, null) != null ? (
              # Merge template base with any inline overrides
              merge(
                local.ruleset_templates[ruleset_entry.template],
                # Exclude 'template' key from overrides
                {
                  for k, v in ruleset_entry : k => v
                  if k != "template"
                }
              )
            ) : null # Template doesn't exist - will be filtered out
            ) : (
            # Direct ruleset name reference (existing behavior)
            lookup(local.rulesets_config, ruleset_entry, null)
          )
        )
      }
    ]...)
  }

  # Merge actions configuration from all groups for each repository
  # Actions config uses deep merge: scalar values override, lists are merged
  # Secure defaults: allowed_actions defaults to "all" to match GitHub's default
  # Merge actions patterns_allowed from all groups + repo-specific patterns
  # Lists are merged (deduplicated) rather than overridden
  merged_actions_patterns = {
    for repo_name, repo_config in local.repos_yaml : repo_name => distinct(flatten(concat(
      # Collect patterns from all groups
      [
        for group_name in repo_config.groups :
        lookup(
          lookup(
            lookup(local.config_groups, group_name, {}),
            "actions",
            {}
          ),
          "allowed_actions_config",
          {}
          ) != {} ? lookup(
          lookup(
            lookup(local.config_groups, group_name, {}),
            "actions",
            {}
          ),
          "allowed_actions_config",
          null
          ) != null ? lookup(
          lookup(
            lookup(
              lookup(local.config_groups, group_name, {}),
              "actions",
              {}
            ),
            "allowed_actions_config",
            {}
          ),
          "patterns_allowed",
          []
        ) : [] : []
      ],
      # Add repo-specific patterns
      lookup(repo_config, "actions", null) != null && lookup(lookup(repo_config, "actions", {}), "allowed_actions_config", null) != null ? [
        lookup(
          lookup(
            lookup(repo_config, "actions", {}),
            "allowed_actions_config",
            {}
          ),
          "patterns_allowed",
          []
        )
      ] : []
    )))
  }

  # Determine effective actions config for each repository
  # This merges group configs with repo-specific overrides and applies secure defaults
  effective_actions = {
    for repo_name, repo_config in local.repos_yaml : repo_name => (
      # Check if ANY actions config exists in groups or repo
      lookup(repo_config, "actions", null) != null ||
      anytrue([
        for group_name in repo_config.groups :
        lookup(lookup(local.config_groups, group_name, {}), "actions", null) != null
      ])
      ) ? {
      # Enabled: repo > groups > true (secure default allows actions)
      enabled = coalesce(
        lookup(repo_config, "actions", null) != null ? lookup(lookup(repo_config, "actions", {}), "enabled", null) : null,
        # Check groups in reverse order (last group wins)
        try([
          for group_name in reverse(repo_config.groups) :
          lookup(
            lookup(
              lookup(local.config_groups, group_name, {}),
              "actions",
              {}
            ),
            "enabled",
            null
          )
          if lookup(
            lookup(
              lookup(local.config_groups, group_name, {}),
              "actions",
              {}
            ),
            "enabled",
            null
          ) != null
        ][0], null),
        true
      )

      # Allowed actions: repo > groups > "all" (GitHub's default)
      allowed_actions = coalesce(
        lookup(repo_config, "actions", null) != null ? lookup(lookup(repo_config, "actions", {}), "allowed_actions", null) : null,
        try([
          for group_name in reverse(repo_config.groups) :
          lookup(
            lookup(
              lookup(local.config_groups, group_name, {}),
              "actions",
              {}
            ),
            "allowed_actions",
            null
          )
          if lookup(
            lookup(
              lookup(local.config_groups, group_name, {}),
              "actions",
              {}
            ),
            "allowed_actions",
            null
          ) != null
        ][0], null),
        "all"
      )

      # Allowed actions config: only included when allowed_actions is "selected"
      allowed_actions_config = {
        github_owned_allowed = coalesce(
          lookup(repo_config, "actions", null) != null &&
          lookup(lookup(repo_config, "actions", {}), "allowed_actions_config", null) != null
          ? lookup(
            lookup(lookup(repo_config, "actions", {}), "allowed_actions_config", {}),
            "github_owned_allowed",
            null
          ) : null,
          try([
            for group_name in reverse(repo_config.groups) :
            lookup(
              lookup(
                lookup(
                  lookup(local.config_groups, group_name, {}),
                  "actions",
                  {}
                ),
                "allowed_actions_config",
                {}
              ),
              "github_owned_allowed",
              null
            )
            if lookup(
              lookup(
                lookup(
                  lookup(local.config_groups, group_name, {}),
                  "actions",
                  {}
                ),
                "allowed_actions_config",
                {}
              ),
              "github_owned_allowed",
              null
            ) != null
          ][0], null),
          true # Secure default: allow github-owned actions
        )

        verified_allowed = coalesce(
          lookup(repo_config, "actions", null) != null &&
          lookup(lookup(repo_config, "actions", {}), "allowed_actions_config", null) != null
          ? lookup(
            lookup(lookup(repo_config, "actions", {}), "allowed_actions_config", {}),
            "verified_allowed",
            null
          ) : null,
          try([
            for group_name in reverse(repo_config.groups) :
            lookup(
              lookup(
                lookup(
                  lookup(local.config_groups, group_name, {}),
                  "actions",
                  {}
                ),
                "allowed_actions_config",
                {}
              ),
              "verified_allowed",
              null
            )
            if lookup(
              lookup(
                lookup(
                  lookup(local.config_groups, group_name, {}),
                  "actions",
                  {}
                ),
                "allowed_actions_config",
                {}
              ),
              "verified_allowed",
              null
            ) != null
          ][0], null),
          true # Secure default: allow verified marketplace actions
        )

        # Patterns are merged from all groups + repo
        patterns_allowed = local.merged_actions_patterns[repo_name]
      }
    } : null
  }
  # Validate that all template references exist
  # Collects any invalid template references across all repos and groups
  # Note: ruleset_entry can be either a string (direct reference) or an object (template reference)
  invalid_template_refs = flatten([
    for repo_name, repo_config in local.repos_yaml : [
      for ruleset_entry in flatten(concat(
        [
          for group_name in repo_config.groups :
          lookup(lookup(local.config_groups, group_name, {}), "rulesets", [])
        ],
        [lookup(repo_config, "rulesets", [])]
        )) : {
        repo     = repo_name
        template = ruleset_entry.template
      }
      # Only validate if it's an object with a template key (not a direct string reference)
      if can(ruleset_entry.template) && try(ruleset_entry.template, null) != null && lookup(local.ruleset_templates, ruleset_entry.template, null) == null
    ]
  ])

  # Calculate effective visibility for each repository (needed for ruleset filtering)
  repo_visibility = {
    for repo_name, repo_config in local.repos_yaml : repo_name =>
    lookup(repo_config, "visibility", lookup(local.merged_configs[repo_name], "visibility", "private"))
  }

  # Filter rulesets based on subscription tier and repository visibility
  # On free tier, rulesets are not available for private repositories
  effective_rulesets = {
    for repo_name, rulesets in local.merged_rulesets : repo_name =>
    (local.rulesets_require_paid_for_private && local.repo_visibility[repo_name] != "public") ? tomap({}) : rulesets
  }

  # Track which repos have rulesets skipped due to subscription limitations
  repos_with_skipped_rulesets = [
    for repo_name, rulesets in local.merged_rulesets : repo_name
    if length(rulesets) > 0 && length(local.effective_rulesets[repo_name]) == 0
  ]

  # Merge webhooks from groups and repo for each repository
  # Later definitions override earlier ones by name (groups applied in order, then repo overrides)
  merged_webhooks_raw = {
    for repo_name, repo_config in local.repos_yaml : repo_name => merge(
      concat(
        # Apply each group's webhooks sequentially - later groups override by name
        [
          for group_name in repo_config.groups : {
            for entry in lookup(lookup(local.config_groups, group_name, {}), "webhooks", []) :
            (can(tostring(entry)) ? tostring(entry) : lookup(entry, "name", "")) => (
              can(tostring(entry)) ?
              # String reference - look up in webhooks_config and normalize types
              {
                url          = tostring(lookup(local.webhooks_config, tostring(entry), { url = null }).url)
                content_type = tostring(lookup(lookup(local.webhooks_config, tostring(entry), {}), "content_type", "json"))
                secret       = try(tostring(lookup(local.webhooks_config, tostring(entry), {}).secret), null)
                events       = tolist(lookup(lookup(local.webhooks_config, tostring(entry), {}), "events", []))
                active       = tobool(lookup(lookup(local.webhooks_config, tostring(entry), {}), "active", true))
                insecure_ssl = tobool(lookup(lookup(local.webhooks_config, tostring(entry), {}), "insecure_ssl", false))
              } :
              # Inline definition
              {
                url          = tostring(lookup(entry, "url", null))
                content_type = tostring(lookup(entry, "content_type", "json"))
                secret       = try(tostring(lookup(entry, "secret", null)), null)
                events       = tolist(lookup(entry, "events", []))
                active       = tobool(lookup(entry, "active", true))
                insecure_ssl = tobool(lookup(entry, "insecure_ssl", false))
              }
            )
            if(can(tostring(entry)) ? tostring(entry) : lookup(entry, "name", "")) != ""
          }
        ],
        # Add repo-specific webhooks (repo overrides group by name)
        [
          {
            for entry in lookup(repo_config, "webhooks", []) :
            (can(tostring(entry)) ? tostring(entry) : lookup(entry, "name", "")) => (
              can(tostring(entry)) ?
              # String reference - look up in webhooks_config and normalize types
              {
                url          = tostring(lookup(local.webhooks_config, tostring(entry), { url = null }).url)
                content_type = tostring(lookup(lookup(local.webhooks_config, tostring(entry), {}), "content_type", "json"))
                secret       = try(tostring(lookup(local.webhooks_config, tostring(entry), {}).secret), null)
                events       = tolist(lookup(lookup(local.webhooks_config, tostring(entry), {}), "events", []))
                active       = tobool(lookup(lookup(local.webhooks_config, tostring(entry), {}), "active", true))
                insecure_ssl = tobool(lookup(lookup(local.webhooks_config, tostring(entry), {}), "insecure_ssl", false))
              } :
              # Inline definition
              {
                url          = tostring(lookup(entry, "url", null))
                content_type = tostring(lookup(entry, "content_type", "json"))
                secret       = try(tostring(lookup(entry, "secret", null)), null)
                events       = tolist(lookup(entry, "events", []))
                active       = tobool(lookup(entry, "active", true))
                insecure_ssl = tobool(lookup(entry, "insecure_ssl", false))
              }
            )
            if(can(tostring(entry)) ? tostring(entry) : lookup(entry, "name", "")) != ""
          }
        ]
      )...
    )
  }

  # Filter out any null webhooks (undefined references) and resolve secrets from webhook_secrets variable
  # Secrets using env:VAR_NAME pattern are looked up in var.webhook_secrets map
  merged_webhooks = {
    for repo_name, webhooks in local.merged_webhooks_raw : repo_name => {
      for name, webhook in webhooks : name => {
        url          = webhook.url
        content_type = webhook.content_type
        # Resolve env:VAR_NAME pattern for secrets using webhook_secrets variable
        secret = (
          webhook.secret != null && can(regex("^env:", webhook.secret)) ?
          lookup(var.webhook_secrets, substr(webhook.secret, 4, -1), null) :
          webhook.secret
        )
        events       = webhook.events
        active       = webhook.active
        insecure_ssl = webhook.insecure_ssl
      }
      if webhook != null
    }
  }



  # Transform YAML repos into the format expected by the module
  # Multiple groups are applied sequentially with proper merging
  repositories = {
    for repo_name, repo_config in local.repos_yaml : repo_name => {
      name         = repo_name
      description  = repo_config.description
      homepage_url = lookup(repo_config, "homepage_url", lookup(local.merged_configs[repo_name], "homepage_url", null))
      config_group = join(", ", repo_config.groups) # Store all groups for reference

      # Apply repo-specific overrides, falling back to merged group config
      visibility                  = lookup(repo_config, "visibility", lookup(local.merged_configs[repo_name], "visibility", "private"))
      has_wiki                    = lookup(repo_config, "has_wiki", lookup(local.merged_configs[repo_name], "has_wiki", false))
      has_issues                  = lookup(repo_config, "has_issues", lookup(local.merged_configs[repo_name], "has_issues", false))
      has_projects                = lookup(repo_config, "has_projects", lookup(local.merged_configs[repo_name], "has_projects", false))
      has_discussions             = lookup(repo_config, "has_discussions", lookup(local.merged_configs[repo_name], "has_discussions", false))
      allow_merge_commit          = lookup(repo_config, "allow_merge_commit", lookup(local.merged_configs[repo_name], "allow_merge_commit", true))
      allow_squash_merge          = lookup(repo_config, "allow_squash_merge", lookup(local.merged_configs[repo_name], "allow_squash_merge", true))
      allow_rebase_merge          = lookup(repo_config, "allow_rebase_merge", lookup(local.merged_configs[repo_name], "allow_rebase_merge", true))
      allow_auto_merge            = lookup(repo_config, "allow_auto_merge", lookup(local.merged_configs[repo_name], "allow_auto_merge", false))
      allow_update_branch         = lookup(repo_config, "allow_update_branch", lookup(local.merged_configs[repo_name], "allow_update_branch", false))
      delete_branch_on_merge      = lookup(repo_config, "delete_branch_on_merge", lookup(local.merged_configs[repo_name], "delete_branch_on_merge", false))
      web_commit_signoff_required = lookup(repo_config, "web_commit_signoff_required", lookup(local.merged_configs[repo_name], "web_commit_signoff_required", false))
      vulnerability_alerts        = lookup(repo_config, "vulnerability_alerts", lookup(local.merged_configs[repo_name], "vulnerability_alerts", true))

      # License template - optional, can be set in group or repo
      license_template = lookup(repo_config, "license_template", lookup(local.merged_configs[repo_name], "license_template", null))

      # Topics: merge from all groups + repo-specific topics
      topics = distinct(concat(
        local.merged_topics[repo_name],
        lookup(repo_config, "topics", [])
      ))

      # Teams: merge from all groups + repo-specific teams (repo overrides group)
      teams = merge(
        local.merged_teams[repo_name],
        lookup(repo_config, "teams", {})
      )

      # Collaborators: merge from all groups + repo-specific collaborators (repo overrides group)
      collaborators = merge(
        local.merged_collaborators[repo_name],
        lookup(repo_config, "collaborators", {})
      )

      # Rulesets: apply rulesets from groups and repo-specific rulesets
      # Note: effective_rulesets filters based on subscription tier
      rulesets = local.effective_rulesets[repo_name]

      # Actions: apply actions configuration from groups and repo-specific settings
      # Returns null if no actions config is specified (resource will be skipped)
      actions = local.effective_actions[repo_name]

      # Webhooks: merge from all groups + repo-specific webhooks (repo overrides group by name)
      webhooks = local.merged_webhooks[repo_name]

    }
  }
}

# Validate that all referenced templates exist
check "template_references" {
  assert {
    condition = length(local.invalid_template_refs) == 0
    error_message = <<-EOT
      Invalid template references found:
      ${join("\n      ", [
    for ref in local.invalid_template_refs :
    "Repository '${ref.repo}' references template '${ref.template}' which does not exist in ${var.config_path}/ruleset/templates.yml"
])}

      Available templates: ${join(", ", keys(local.ruleset_templates))}
    EOT
}
}
